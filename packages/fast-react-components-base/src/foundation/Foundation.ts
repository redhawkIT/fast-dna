import * as React from "react";
import * as ReactDOM from "react-dom";
import { set, get, pick, has } from "lodash-es";

export interface IUnhandledProps {
    [key: string]: any;
}

class Foundation<P, S> extends React.Component<P, S> {
    /**
     * default props for the component
     */
    public static defaultProps: object;

    /**
     * Stores ref objects themselves.
     * @name references
     * @type {object}
     */
    protected references: {
        [name: string]: any;
    } = {};

    /**
     * Stores ref callbacks by name
     * @name refResolvers
     * @type {object}
     */
    private refResolvers: {
        [name: string]: (ref?: any) => void;
    } = {};

    /**
     * Creates, store, and returns a new ref resolver callback in the case where a callback hasn't been created for that key yet,
     * but otherwise returns the memoized function by that key.
     * @name setRef
     * @param ...args {string[]} - The key structure to store the resulting ref on.
     * @param ...args {number[]} - The index structure to store the resulting ref on.
     * @param ...args {boolean[]} - Pass 'true' if the method should resolve React Component references to dom nodes.
     */
    protected setRef(...args: Array<(string | boolean | number)>): (ref?: any) => void {
        let resolveComponentsToDom: boolean = false;
        let key: (string | number);
        const keys: any[] = args.filter((arg: (string | boolean | number)) => {
            if (typeof arg === "string" || typeof arg === "number") {
                return true;
            }

            if (typeof arg === "boolean") {
                resolveComponentsToDom = arg;
                return false;
            }
        }) as Array<(string | number)>;

        // get/set will resolves keys like 'foo[0]' to an arry if the sole param passed
        // is a string. To support this, if we only have 1 param, we should
        // not pass it as an array
        if (keys.length === 1) {
            key = keys[0] as string;
        }

        // If we haven't stored a resolver function for this key yet,
        // create one and store it
        if (!get(this.refResolvers, key || keys)) {
            set(this.refResolvers, key || keys, (ref: any) => {
                if (resolveComponentsToDom) {
                    ref = ReactDOM.findDOMNode(ref);
                }

                return set(this.references, key || keys, ref);
            });
        }

        return get(this.refResolvers, key || keys);
    }

    /**
     * gets a reference stored by the baseclass by keyname, where arguments are
     * used as keynames, eg getRef('foo', 'bar', 0) resolves to this.references.foo.bar[0];
     * @param args {(string|number)[]}
     */
    protected getRef(...args: Array<(string | number)>): any {
        let key: (string | number);

        if (args.length === 1) {
            key = args[0];
        }

        return get(this.references, key || args);
    }

    /**
     * Gets all props that aren't handled by the component.
     * @return {object} - an object containing all properties of 'props' that are not found on defaultProps
     */
    protected unhandledProps(): IUnhandledProps {
        const defaultPropsKey: string = "defaultProps";
        const defaultProps: object = this.constructor[defaultPropsKey];

        if (!defaultProps) {
            return this.props;
        }

        return pick(this.props, Object.keys(this.props).filter((key: any) => {
            return !has(defaultProps, key);
        }));
    }

    /**
     * Concatenates a component's generated className string with any additional classNames passed as props.
     * @param {string} componentClasses the HTML class attribute string generated by the component
     */
    protected generateClassNames(componentClasses?: string): string {
        const hasComponentClasses: boolean = typeof componentClasses === "string";
        const classKey: string = "className";

        if (!has(this.props, classKey)) {
            return hasComponentClasses ? componentClasses : null;
        }

        if (!hasComponentClasses) {
            return this.props[classKey];
        }

        return componentClasses.concat(` ${this.props[classKey]}`).trim().replace(/(\s){2,}/g, " ");
    }
}

export default Foundation;
